/* Copyright Â© 2016 EIS Group and/or one of its affiliates. All rights reserved. Unpublished work under U.S. copyright laws.
 CONFIDENTIAL AND TRADE SECRET INFORMATION. No portion of this work may be copied, distributed, modified, or incorporated into any other media without EIS Group prior written consent.*/
package com.eisgroup.dependencyreport.goals;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.Stack;
import java.util.jar.JarFile;
import java.util.stream.Collectors;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.repository.ArtifactRepository;
import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.model.License;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.DefaultProjectBuildingRequest;
import org.apache.maven.project.MavenProject;
import org.apache.maven.project.ProjectBuilder;
import org.apache.maven.shared.artifact.filter.StrictPatternExcludesArtifactFilter;
import org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;
import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;
import org.apache.maven.shared.dependency.graph.DependencyNode;
import org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;
import org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;
import org.apache.maven.shared.dependency.graph.filter.ArtifactDependencyNodeFilter;
import org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;
import org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;
import org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;
import org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import com.eisgroup.dependencyreport.core.DependencyInfoData;
import com.eisgroup.dependencyreport.core.LicenseInfoData;
import com.eisgroup.dependencyreport.core.ReportGenerationException;
import com.eisgroup.dependencyreport.core.XMLLicense;
import com.eisgroup.dependencyreport.report.spreadsheet.SpreadsheetReportWriter;
import com.eisgroup.dependencyreport.utils.ReportUtils;
import com.eisgroup.dependencyreport.utils.SpreadsheetUtils;

/*
 * Goal for generating dependency report on a project level.
 */
@Mojo(name = "report", defaultPhase = LifecyclePhase.SITE, threadSafe = true)
public class ReportMojo extends AbstractMojo {
	@Component private MavenProject mavenProject;

	@Component private MavenSession mavenSession;

	@Component private ProjectBuilder projectBuilder;

	@Component(hint = "default") private DependencyGraphBuilder dependencyGraphBuilder;

	/*
	 * A comma-separated list of artifacts to filter from the serialized dependency tree, or null not to filter any artifacts from the dependency tree.
	 * The filter syntax is: [groupId]:[artifactId]:[type]:[version]
	 * where each pattern segment is optional and supports full and partial * wildcards. An empty pattern segment is treated as an implicit wildcard.
	 * For example, org.apache.* will match all artifacts whose group id starts with org.apache., and :::*-SNAPSHOT will match all snapshot artifacts.
	 */
	@Parameter(property = "excludes") private String excludes;

	/*
	 * An XML licenses file generated by maven license plugin
	 * https://www.mojohaus.org/license-maven-plugin/index.html
	 */
	@Parameter(property = "license-xml-file") private String licenseXMLFile;

	// "groupId:artifactId" of the parent project, where input spreadsheet is located
	@Parameter(property = "reportInputFileProjectId") private String reportInputFileProjectId;

	// Skip plugin execution
	@Parameter(defaultValue = "false") private boolean skip;

	private List<LicenseInfoData> licenseXMLData = new ArrayList<>();

	public void execute() throws MojoExecutionException {

		if (skip) {
			getLog().info("Plugin execution is set to skip. Skipping plugin execution.");
			return;
		}
		if (licenseXMLFile != null) {
			licenseXMLData = readLicenseInfoFromPredefinedXMLFile(licenseXMLFile, getLog());
		}
		try {
			// Collect dependency information
			List<DependencyNode> collectedNodes = collectNodes();

			getLog().info("Total number of dependencies collected: " + collectedNodes.size());
			// Calculate destination directory for project report.
			Path projectReportDestinationPath = ReportUtils.resolveReportOutputFilePath(mavenProject, getLog());
			getLog().info("Location of the report output file: " + projectReportDestinationPath);
			// Convert nodes to data holder objects. The purpose of this, is to simplify
			// data retrieval in later steps of report generation.
			List<DependencyInfoData> dependencyInfoDataList = collectData(collectedNodes);

			List<DependencyInfoData> emptyDependencyPathArtifacts = dependencyInfoDataList.stream()
					.filter(s -> s.getDependencyPath() == null || s.getDependencyPath().trim().length() == 0)
					.collect(Collectors.toList());

			if (emptyDependencyPathArtifacts.size() > 0) {
				dependencyInfoDataList.removeAll(emptyDependencyPathArtifacts);
			}

			// If input report file location property exists, then process it.
			if (reportInputFileProjectId != null) {
				// Find the project, where input spreadsheet is located.
				MavenProject projectContainingInputSpreadsheet = ReportUtils.findMavenAncestorOrSelfProjectById(mavenProject, reportInputFileProjectId);
				getLog().info("Project containing report input file: " + projectContainingInputSpreadsheet.getGroupId() + ":" + projectContainingInputSpreadsheet.getArtifactId());
				// Calculate input spreadsheet directory for data override.
				Path inputReportPath = ReportUtils.resolveReportInputFilePath(projectContainingInputSpreadsheet, getLog());
				getLog().info("Location of the input file for the report: " + inputReportPath);

				SpreadsheetUtils.updateWithDataFromInputSpreadsheet(inputReportPath, dependencyInfoDataList, getLog());
			}

			SpreadsheetReportWriter reportHandler = new SpreadsheetReportWriter(dependencyInfoDataList, getLog());

			reportHandler.writeReport(projectReportDestinationPath);
			getLog().info("Report was successfully written.");
		} catch (DependencyGraphBuilderException e) {
			getLog().error(e);
			throw new MojoExecutionException("Failed to build dependency tree.", e);
		} catch (IOException e) {
			getLog().error(e);
			throw new MojoExecutionException(e.getMessage());
		} catch (ReportGenerationException e) {
			getLog().error(e);
			throw new MojoExecutionException("Failed to generate report.", e);
		} catch (Exception e) {
			getLog().error(e);
			throw new MojoExecutionException("Unexpected errors occurred.", e);
		}
	}


	/*
	 * Collects all data needed for each DependencyNode into list of DependencyInfoData objects.
	 */
	private List<DependencyInfoData> collectData(List<DependencyNode> collectedNodes) {
		List<DependencyInfoData> convertedNodes = new ArrayList<>(collectedNodes.size());
		for (DependencyNode node : collectedNodes) {
			convertedNodes.add(collectDataForNode(node));
		}

		return convertedNodes;
	}

	/*
	 * Collects data from DependencyNode to DependencyInfoData object.
	 */
	private DependencyInfoData collectDataForNode(DependencyNode dependencyNode) {
		DependencyInfoData dependencyInfoData = new DependencyInfoData();

		Artifact artifact = dependencyNode.getArtifact();
		dependencyInfoData.setRootProjectName(mavenProject.getArtifactId());
		dependencyInfoData.setGroupId(artifact.getGroupId());
		dependencyInfoData.setArtifactId(artifact.getArtifactId());
		dependencyInfoData.setVersion(artifact.getVersion());
		dependencyInfoData.setScope(artifact.getScope());

		// Missing data is taken from MavenProject object. 
		MavenProject mavenProject = ReportUtils.getMavenProjectFromArtifact(artifact, projectBuilder, mavenSession, getLog());
		Optional<LicenseInfoData> licenseFromXMLFile = findLicenseFromXMLFileName(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion());


		if (mavenProject != null) {

			// Update License name and URL
			List<License> licenses = mavenProject.getLicenses();
			if (licenses.size() == 1) {
				dependencyInfoData.setLicenseName(licenses.get(0).getName());
				dependencyInfoData.setLicenseUrl(licenses.get(0).getUrl());
			} else if (licenses.size() > 1) {
				dependencyInfoData.setLicenseName(String.join("\n", licenses.stream().filter(l -> l.getName() != null)
						.map(l -> l.getName().concat(" (").concat(String.valueOf(l.getUrl())).concat(")"))
						.collect(Collectors.toSet())));
			} else if (licenseFromXMLFile.isPresent()
					&& licenseFromXMLFile.get().getLicenses() != null) {
				// find license in XML file
				if (licenseFromXMLFile.get().getLicenses().size() == 1) {
					dependencyInfoData.setLicenseName(licenseFromXMLFile.get().getLicenses().get(0).getName());
					dependencyInfoData.setLicenseUrl(licenseFromXMLFile.get().getLicenses().get(0).getUrl());
				} else if (licenseFromXMLFile.get().getLicenses().size() > 1) {
					dependencyInfoData.setLicenseName(String.join("\n", licenseFromXMLFile.get().getLicenses().stream().filter(l -> l.getName() != null)
							.map(l -> l.getName().concat(" (").concat(String.valueOf(l.getUrl())).concat(")"))
							.collect(Collectors.toSet())));
				}
			}

			// Update License filename
			if (licenseFromXMLFile.isPresent() && licenseFromXMLFile.get().getLicenses() != null) {
				Set<String> collect = licenseFromXMLFile.get().getLicenses().stream().filter(l -> l.getFilename() != null).map(XMLLicense::getFilename).collect(Collectors.toSet());
				dependencyInfoData.setLicenseFileName(String.join("\n", collect));
			}

			// Look for license inside jar file
			if (dependencyInfoData.getLicenseFileName()==null) {
				String internalFileName = findLicenseInJar(artifact, null, mavenSession.getLocalRepository());
				if (internalFileName != null) {
					dependencyInfoData.setInternalLicenseFileName(internalFileName.replaceFirst(mavenSession.getLocalRepository().getUrl(), SpreadsheetUtils.VALUE_EMPTY));
				}
			}

			// Update artifact is modified by EIS (pom.xml->scm->url contains eisgroup or exigengroup)
			if (mavenProject.getScm() != null && mavenProject.getScm().getUrl() != null) {
				if (isEisScmRepository(mavenProject.getScm().getUrl())) {
					dependencyInfoData.setModified(true);
				}
			}

			dependencyInfoData.setDescription(cleanDescriptionValue(mavenProject.getDescription()));
			dependencyInfoData.setUrl(mavenProject.getUrl());
			dependencyInfoData.setDependencyPath(getHierarchyPathOfTheNode(dependencyNode));
		}

		return dependencyInfoData;
	}

	private Optional<LicenseInfoData> findLicenseFromXMLFileName(String groupId, String artifactId, String version) {
		if (this.licenseXMLFile == null) {
			return Optional.empty();
		}

		if (groupId != null && artifactId != null && version != null) {
			return licenseXMLData.stream().filter(l -> l.getGroupId().trim().equalsIgnoreCase(groupId)
					&& l.getArtifactId().trim().equalsIgnoreCase(artifactId)
					&& l.getVersion().trim().equalsIgnoreCase(version)).findFirst();
		}

		if (groupId != null && artifactId != null) {
			return licenseXMLData.stream().filter(l -> l.getGroupId().trim().equalsIgnoreCase(groupId)
					&& l.getArtifactId().trim().equalsIgnoreCase(artifactId)).findFirst();
		}

		if (groupId != null) {
			return licenseXMLData.stream().filter(l -> l.getGroupId().trim().equalsIgnoreCase(groupId)).findFirst();
		}

		return Optional.empty();
	}

	private static final List<String> EIS_REPOSITORIES = Arrays.asList("exigengroup.com", "eisgroup.com");

	private boolean isEisScmRepository(String scmURL) {
		for (String eisRepository : EIS_REPOSITORIES) {
			if (scmURL.contains(eisRepository)) {
				return true;
			}
		}
		return false;
	}

	/*
	 * Sometimes description for some reason contains new line or multiple whitespace characters.
	 * Replace those with single space character to make it one-liner.
	 */
	public static String cleanDescriptionValue(String description) {
		if (description != null) {
			description = description.replace("\n", " ").replaceAll("\\s{2,}", " ");
		}

		return description;
	}

	/*
	 * Logic is taken from org.apache.maven.plugin.dependency.tree.TreeMojo.serializeDependencyTree()
	 * Results should be consistent with dependency:tree plugin execution.
	 */
	private List<DependencyNode> collectNodes() throws DependencyGraphBuilderException {
		DefaultProjectBuildingRequest request = new DefaultProjectBuildingRequest();
		request.setProject(this.mavenProject);
		request.setRepositorySession(this.mavenSession.getRepositorySession());

		// build dependency graph and get the root node
		DependencyNode rootNode = dependencyGraphBuilder.buildDependencyGraph(request, null);

		// collects all the nodes in the graph
		CollectingDependencyNodeVisitor collectingDependencyNodeVisitor = new CollectingDependencyNodeVisitor();

		DependencyNodeFilter filter = createDependencyNodeFilter();

		if (filter != null) {
			// collect all the nodes in the graph with filter applied
			DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor(collectingDependencyNodeVisitor, filter);
			rootNode.accept(firstPassVisitor);

			CollectingDependencyNodeVisitor collectingDependencyNodeVisitorForSecondPass = new CollectingDependencyNodeVisitor();
			DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter(collectingDependencyNodeVisitor.getNodes());

			AndDependencyNodeFilter andFilter = new AndDependencyNodeFilter(filter, secondPassFilter);
			DependencyNodeVisitor visitor = new FilteringDependencyNodeVisitor(collectingDependencyNodeVisitorForSecondPass, andFilter);
			rootNode.accept(visitor);
			return collectingDependencyNodeVisitorForSecondPass.getNodes();
		}

		rootNode.accept(collectingDependencyNodeVisitor);
		return collectingDependencyNodeVisitor.getNodes();
	}

	/*
	 * In case filter ("excludes" property) is applied
	 */
	private DependencyNodeFilter createDependencyNodeFilter() {
		List<DependencyNodeFilter> filters = new ArrayList<DependencyNodeFilter>();
		DependencyNodeFilter filter;

		// filter excludes
		if (excludes != null) {
			List<String> patterns = Arrays.asList(excludes.split(","));

			getLog().debug("+ Filtering dependency tree by artifact exclude patterns: " + patterns);

			ArtifactFilter artifactFilter = new StrictPatternExcludesArtifactFilter(patterns);
			filter = new ArtifactDependencyNodeFilter(artifactFilter);
			filters.add(filter);
		}

		return filters.isEmpty() ? null : new AndDependencyNodeFilter(filters);
	}

	/*
	 * Walks through dependency tree from node to its last ancestor and builds
	 * path string in reverse order (from ascendant to node analyzed)
	 */
	private String getHierarchyPathOfTheNode(DependencyNode node) {
		Stack<Artifact> stack = new Stack<Artifact>();

		while (node != null) {
			stack.push(node.getArtifact());
			node = node.getParent();
		}

		StringBuilder builder = new StringBuilder();
		while (!stack.isEmpty()) {
			Artifact artifact = stack.pop();

			String groupId = (artifact.getGroupId() != null) ? artifact.getGroupId() : SpreadsheetUtils.VALUE_EMPTY;
			String artifactId = (artifact.getArtifactId() != null) ? artifact.getArtifactId() : SpreadsheetUtils.VALUE_EMPTY;
			String version = (artifact.getVersion() != null) ? artifact.getVersion() : SpreadsheetUtils.VALUE_EMPTY;
			String scope = (artifact.getScope() != null) ? artifact.getScope() : SpreadsheetUtils.VALUE_EMPTY;

			builder.append(groupId + ":" + artifactId + ":" + version + ":" + scope);

			if (!stack.isEmpty()) {
				builder.append(" --> ");
			}
		}

		return builder.toString();
	}


	/**
	 * Read License info from XML file
	 * @param fileName - filename
	 * @param log - logger instance
	 * @return List of LicenseInfoData
	 */
	private static List<LicenseInfoData> readLicenseInfoFromPredefinedXMLFile(String fileName, Log log) {
		List<LicenseInfoData> data = new ArrayList<>();
		File licensesFile = new File(fileName);
		if (!licensesFile.exists()) {
			log.error("file was not found:" + fileName);
			return data;
		}
		if (!licensesFile.isFile()) {
			log.error("not a file: " + fileName);
			return data;
		}

		try {
			Document doc = Jsoup.parse(licensesFile, "UTF-8");
			Elements elems = doc.getElementsByTag("dependency");

			for (Element elem : elems) {
				String groupId = null;
				String artifactId = null;
				String version = null;

				groupId = elem.getElementsByTag("groupId").get(0).text();

				if (elem.getElementsByTag("artifactId")!=null && elem.getElementsByTag("artifactId").get(0) != null) {
					artifactId = elem.getElementsByTag("artifactId").get(0).text();
				}

				if (elem.getElementsByTag("version")!=null && elem.getElementsByTag("version").get(0) != null) {
					version = elem.getElementsByTag("version").get(0).text();
				}

				LicenseInfoData licenseInfoData = new LicenseInfoData(groupId, artifactId, version);

				Elements licenseElements = elem.getElementsByTag("license");
				if (licenseElements != null && licenseElements.size() > 0) {
					licenseInfoData.setLicenses(new ArrayList<>());

					for (Element licenseElement : licenseElements) {
						String licenseName = null;
						String licenseUrl = null;
						String licenseFilename = null;
						if (licenseElement.getElementsByTag("name") != null && licenseElement.getElementsByTag("name").size() > 0) {
							licenseName = licenseElement.getElementsByTag("name").get(0).text();
						}
						if (licenseElement.getElementsByTag("url") != null && licenseElement.getElementsByTag("url").size() > 0) {
							licenseUrl = licenseElement.getElementsByTag("url").get(0).text();
						}
						if (licenseElement.getElementsByTag("file") != null && licenseElement.getElementsByTag("file").size() > 0) {
							licenseFilename = licenseElement.getElementsByTag("file").get(0).text();
						}
						licenseInfoData.getLicenses().add(new XMLLicense(licenseName, licenseUrl, licenseFilename));
					}
				}
				data.add(licenseInfoData);
			}
		} catch (IOException e) {
			log.error("failed to parse XML file: " + fileName);
			log.error(e.getMessage());
		}
		return data;
	}

	protected static final List LICENSE_PATH_OPTIONS = Arrays
			.asList(new String[] { "LICENSE", "LICENSE.txt", "META-INF/LICENSE", "META-INF/LICENSE.txt", "license", "license.txt", "META-INF/license", "META-INF/license.txt", });

	/**
	 * Attempts to find the JAR file for this artifact and then the given file
	 * path in the JAR. If the entry does not exist - will try to search for
	 * other potential license locations inside the JAR as defined in
	 * {@link #LICENSE_PATH_OPTIONS}
	 *
	 * @param artifact - will be used to lookup the JAR file for this artifact
	 * @param filePath - path to the license inside the JAR
	 * @return a valid URL to the license file or null if no valid JAR or entry
	 * is found
	 */
	private String findLicenseInJar(Artifact artifact, String filePath, ArtifactRepository localRepository) {
		final String jarPath = "jar:" + localRepository.getUrl() + File.separator + localRepository.pathOf(artifact);
		if (filePath != null && filePath.length() != 0) {
			// check the given URL if it is valid
			// make sure we do not much up the path as JAR entries are sensitive
			// to having "//" in them
			if (filePath.startsWith("/") || filePath.startsWith("\\")) {
				filePath = "META-INF" + filePath;
			} else {
				filePath = "META-INF/" + filePath;
			}
			// validate
			String url = toUrl(jarPath, filePath);
			if (url != null) { return url; }
		}
		for (Iterator iter = LICENSE_PATH_OPTIONS.iterator(); iter.hasNext(); ) {
			String url = toUrl(jarPath, (String) iter.next());
			if (url != null) {
				return url;
			}
		}
		return null;
	}

	private String toUrl(String jarPath, String entry) {
		try {
			if (new JarFile(jarPath).getEntry(entry) != null) {
				return jarPath + "!/" + entry;
			} else {
				if (getLog().isDebugEnabled()) { getLog().debug("Entry " + entry + " is not found in " + jarPath); }
				return null;
			}
		} catch (Exception e) {
			if (jarPath.startsWith("jar:file:///")) {
				String shortJarUrl = jarPath.substring(12);
				try {
					if (new JarFile(shortJarUrl).getEntry(entry) != null) {
						return jarPath + "!/" + entry;
					} else {
						if (getLog().isDebugEnabled()) { getLog().debug("Entry " + entry + " is not found in " + jarPath); }
						return null;
					}
				} catch (Exception e2) {
					if (getLog().isDebugEnabled()) { getLog().debug("Path is invalid: " + jarPath, e2); }
				}
			}

			if (getLog().isDebugEnabled()) { getLog().debug("Path is invalid: " + jarPath, e); }
			return null;
		}
	}

}